# Google GenAI MCP Toolbox Configuration
# This file defines database sources and tools for ADK agents

# Database sources
sources:
  postgres-main:
    kind: postgres
    host: localhost
    port: 5432
    database: testgendb
    user: postgres
    password: your_password
    # For Google Cloud SQL, use connection_name instead:
    # connection_name: "your-project:region:instance-name"
    # For Cloud SQL Proxy:
    # host: "/cloudsql/your-project:region:instance-name"
    # port: 5432

# Available tools for ADK agents
tools:
  # Session Management Tools
  create-session:
    kind: postgres-sql
    source: postgres-main
    description: Create a new agent session for workflow tracking
    parameters:
      - name: user_id
        type: string
        description: User identifier for the session
      - name: user_prompt
        type: string
        description: Initial user prompt that started the session
      - name: project_name
        type: string
        description: Optional project name for organization
    statement: |
      INSERT INTO sessions (session_id, user_id, user_prompt, project_name)
      VALUES (uuid_generate_v4(), $1, $2, $3)
      RETURNING session_id, user_id, user_prompt, project_name, status, created_at;

  get-session:
    kind: postgres-sql
    source: postgres-main
    description: Retrieve session details by session ID
    parameters:
      - name: session_id
        type: string
        description: Session UUID to retrieve
    statement: |
      SELECT session_id, user_id, user_prompt, project_name, status, created_at, updated_at
      FROM sessions
      WHERE session_id = $1::uuid;

  update-session-status:
    kind: postgres-sql
    source: postgres-main
    description: Update session status (active, completed, archived)
    parameters:
      - name: session_id
        type: string
        description: Session UUID to update
      - name: status
        type: string
        description: New status (active, completed, archived)
    statement: |
      UPDATE sessions
      SET status = $2, updated_at = CURRENT_TIMESTAMP
      WHERE session_id = $1::uuid
      RETURNING session_id, status, updated_at;

  # Requirements Management Tools
  store-requirement:
    kind: postgres-sql
    source: postgres-main
    description: Store a requirement analysis for a session
    parameters:
      - name: session_id
        type: string
        description: Session UUID
      - name: content
        type: string
        description: Requirement content text
      - name: requirement_type
        type: string
        description: Type of requirement (functional, non-functional, security, etc.)
      - name: priority
        type: string
        description: Priority level (low, medium, high, critical)
    statement: |
      INSERT INTO requirements (requirement_id, session_id, content, requirement_type, priority)
      VALUES (uuid_generate_v4(), $1::uuid, $2, $3, $4)
      RETURNING requirement_id, session_id, content, requirement_type, priority, created_at;

  get-requirements:
    kind: postgres-sql
    source: postgres-main
    description: Get all requirements for a specific session
    parameters:
      - name: session_id
        type: string
        description: Session UUID
    statement: |
      SELECT requirement_id, session_id, content, requirement_type, priority, created_at
      FROM requirements
      WHERE session_id = $1::uuid
      ORDER BY created_at;

  get-requirements-by-type:
    kind: postgres-sql
    source: postgres-main
    description: Get requirements filtered by type
    parameters:
      - name: session_id
        type: string
        description: Session UUID
      - name: requirement_type
        type: string
        description: Type filter (functional, security, etc.)
    statement: |
      SELECT requirement_id, session_id, content, requirement_type, priority, created_at
      FROM requirements
      WHERE session_id = $1::uuid AND requirement_type = $2
      ORDER BY priority DESC, created_at;

  # Test Case Management Tools
  store-test-case:
    kind: postgres-sql
    source: postgres-main
    description: Store a structured test case with JSON content
    parameters:
      - name: session_id
        type: string
        description: Session UUID
      - name: test_id
        type: string
        description: Human-readable test identifier (e.g., TC_AUTH_001)
      - name: summary
        type: string
        description: Brief test case summary
      - name: priority
        type: string
        description: Test priority (LOW, MEDIUM, HIGH, CRITICAL)
      - name: test_type
        type: string
        description: Test type (functional, security, edge case, negative)
      - name: test_content
        type: string
        description: JSON content containing test details
    statement: |
      INSERT INTO test_cases (test_case_id, session_id, test_id, summary, priority, test_type, test_content)
      VALUES (uuid_generate_v4(), $1::uuid, $2, $3, $4, $5, $6::jsonb)
      RETURNING test_case_id, session_id, test_id, summary, priority, test_type, created_at;

  get-test-cases:
    kind: postgres-sql
    source: postgres-main
    description: Get all test cases for a specific session
    parameters:
      - name: session_id
        type: string
        description: Session UUID
    statement: |
      SELECT test_case_id, session_id, test_id, summary, priority, test_type, test_content, created_at
      FROM test_cases
      WHERE session_id = $1::uuid
      ORDER BY priority DESC, created_at;

  get-test-cases-by-priority:
    kind: postgres-sql
    source: postgres-main
    description: Get test cases filtered by priority level
    parameters:
      - name: session_id
        type: string
        description: Session UUID
      - name: priority
        type: string
        description: Priority filter (LOW, MEDIUM, HIGH, CRITICAL)
    statement: |
      SELECT test_case_id, session_id, test_id, summary, priority, test_type, test_content, created_at
      FROM test_cases
      WHERE session_id = $1::uuid AND priority = $2
      ORDER BY created_at;

  search-test-cases:
    kind: postgres-sql
    source: postgres-main
    description: Search test cases by content using JSONB queries
    parameters:
      - name: session_id
        type: string
        description: Session UUID
      - name: search_term
        type: string
        description: Search term to find in test content
    statement: |
      SELECT test_case_id, session_id, test_id, summary, priority, test_type, test_content, created_at
      FROM test_cases
      WHERE session_id = $1::uuid
        AND (
          summary ILIKE '%' || $2 || '%'
          OR test_content::text ILIKE '%' || $2 || '%'
        )
      ORDER BY priority DESC, created_at;

  # Complex Queries - Session Context
  get-session-context:
    kind: postgres-sql
    source: postgres-main
    description: Get complete session with all requirements and test cases
    parameters:
      - name: session_id
        type: string
        description: Session UUID
    statement: |
      SELECT
        s.session_id,
        s.user_id,
        s.user_prompt,
        s.project_name,
        s.status,
        s.created_at as session_created_at,
        s.updated_at as session_updated_at,
        COALESCE(
          json_agg(
            DISTINCT json_build_object(
              'requirement_id', r.requirement_id,
              'content', r.content,
              'requirement_type', r.requirement_type,
              'priority', r.priority,
              'created_at', r.created_at
            )
          ) FILTER (WHERE r.requirement_id IS NOT NULL),
          '[]'::json
        ) as requirements,
        COALESCE(
          json_agg(
            DISTINCT json_build_object(
              'test_case_id', tc.test_case_id,
              'test_id', tc.test_id,
              'summary', tc.summary,
              'priority', tc.priority,
              'test_type', tc.test_type,
              'test_content', tc.test_content,
              'created_at', tc.created_at
            )
          ) FILTER (WHERE tc.test_case_id IS NOT NULL),
          '[]'::json
        ) as test_cases
      FROM sessions s
      LEFT JOIN requirements r ON s.session_id = r.session_id
      LEFT JOIN test_cases tc ON s.session_id = tc.session_id
      WHERE s.session_id = $1::uuid
      GROUP BY s.session_id, s.user_id, s.user_prompt, s.project_name, s.status, s.created_at, s.updated_at;

  get-session-summary:
    kind: postgres-sql
    source: postgres-main
    description: Get session summary with counts
    parameters:
      - name: session_id
        type: string
        description: Session UUID
    statement: |
      SELECT
        s.session_id,
        s.user_id,
        s.user_prompt,
        s.project_name,
        s.status,
        s.created_at,
        s.updated_at,
        COUNT(DISTINCT r.requirement_id) as requirement_count,
        COUNT(DISTINCT tc.test_case_id) as test_case_count,
        COUNT(DISTINCT CASE WHEN tc.priority = 'CRITICAL' THEN tc.test_case_id END) as critical_tests,
        COUNT(DISTINCT CASE WHEN tc.priority = 'HIGH' THEN tc.test_case_id END) as high_priority_tests
      FROM sessions s
      LEFT JOIN requirements r ON s.session_id = r.session_id
      LEFT JOIN test_cases tc ON s.session_id = tc.session_id
      WHERE s.session_id = $1::uuid
      GROUP BY s.session_id, s.user_id, s.user_prompt, s.project_name, s.status, s.created_at, s.updated_at;

  # Analytics and Reporting
  get-user-sessions:
    kind: postgres-sql
    source: postgres-main
    description: Get all sessions for a specific user
    parameters:
      - name: user_id
        type: string
        description: User identifier
    statement: |
      SELECT
        s.session_id,
        s.user_prompt,
        s.project_name,
        s.status,
        s.created_at,
        s.updated_at,
        COUNT(DISTINCT r.requirement_id) as requirement_count,
        COUNT(DISTINCT tc.test_case_id) as test_case_count
      FROM sessions s
      LEFT JOIN requirements r ON s.session_id = r.session_id
      LEFT JOIN test_cases tc ON s.session_id = tc.session_id
      WHERE s.user_id = $1
      GROUP BY s.session_id, s.user_prompt, s.project_name, s.status, s.created_at, s.updated_at
      ORDER BY s.created_at DESC;

  get-active-sessions:
    kind: postgres-sql
    source: postgres-main
    description: Get all active sessions across all users
    statement: |
      SELECT
        s.session_id,
        s.user_id,
        s.user_prompt,
        s.project_name,
        s.created_at,
        s.updated_at,
        COUNT(DISTINCT r.requirement_id) as requirement_count,
        COUNT(DISTINCT tc.test_case_id) as test_case_count
      FROM sessions s
      LEFT JOIN requirements r ON s.session_id = r.session_id
      LEFT JOIN test_cases tc ON s.session_id = tc.session_id
      WHERE s.status = 'active'
      GROUP BY s.session_id, s.user_id, s.user_prompt, s.project_name, s.created_at, s.updated_at
      ORDER BY s.updated_at DESC;

# Tool groupings for different use cases
toolsets:
  # Basic session management
  session-management:
    - create-session
    - get-session
    - update-session-status
    - get-user-sessions

  # Requirements workflow
  requirements-workflow:
    - store-requirement
    - get-requirements
    - get-requirements-by-type

  # Test case management
  test-case-management:
    - store-test-case
    - get-test-cases
    - get-test-cases-by-priority
    - search-test-cases

  # Complete agent workflow (most comprehensive)
  complete-workflow:
    - create-session
    - get-session
    - update-session-status
    - store-requirement
    - get-requirements
    - get-requirements-by-type
    - store-test-case
    - get-test-cases
    - get-test-cases-by-priority
    - search-test-cases
    - get-session-context
    - get-session-summary

  # Analytics and reporting
  analytics:
    - get-session-summary
    - get-user-sessions
    - get-active-sessions
    - get-session-context

  # Minimal set for basic testing
  basic-tools:
    - create-session
    - store-requirement
    - store-test-case
    - get-session-context